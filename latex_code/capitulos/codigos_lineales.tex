% !TeX root = ../libro.tex
% !TeX encoding = utf8

%\setchapterpreamble[c][0.75\linewidth]{%
%	\sffamily
%  Breve resumen del capítulo. TODO
%	\par\bigskip
%}

\chapter{Códigos de bloque}\label{ch:segundo-capitulo}

En este capítulo trataremos algunos de los fundamentos de la teoría de códigos de bloque, centrándonos principalmente en los códigos lineales. Partiremos de la definición más básica de código, es decir, un subconjunto de un cuerpo finito. Después se definirá el concepto de código lineal, añadiendo a los códigos una estructura de espacio vectorial que nos permitirá utilizar herramientas más potentes propias del álgebra lineal. Por último, estudiaremos una subclase de los códigos lineales, los códigos cíclicos. Estos nos permitirán aplicar algoritmos de decodificación muy eficientes. Las principales fuentes consultadas para este capítulo han sido \cite{Huffman_Pless_2010} y \cite{betten2006error}.


\section{Códigos lineales}\label{sec:1.1}

Consideremos el espacio vectorial de todas las $n$-tuplas sobre el cuerpo finito $\mathds{F}_{q}$, que denotaremos $\mathds{F}_{q}^{n}$.

\begin{definicion}
 Un $(n,M)$-código $\mathcal{C}$ sobre el cuerpo $\mathds{F}_{q}$ es un subconjunto de $\mathds{F}_{q}^{n}$ de tamaño $M$. A los elementos de $\mathcal{C}$ los llamaremos \textit{palabras código}. A $n$ se le llama la \textit{longitud} del código. Normalmente, cada vector $(a_1,a_2,...,a_n) \in \mathds{F}_{q}^{n}$ lo escribiremos de forma más compacta como $a_1\dotsb a_n$.
\end{definicion}

\begin{ejemplo}
Un elemplo de código podría ser un (4,6)-código formado por los siguientes elementos:

$$ 1100, \quad		1011, \quad			1101, \quad			1110,	\quad		1111,	\quad		0001. $$
\end{ejemplo}
Sin ninguna estructura adicional, las propiedades de un código son limitadas. Por tanto, dotaremos al código de \emph{linealidad}. Esto nos permitirá aplicar herramientas matemáticas más potentes que nos hagan sacarle más provecho.

\begin{definicion}
$\mathcal{C}$ es un $[n,k]$-código lineal sobre $\mathds{F}_{q}$ si es un subespacio $k$-dimensional de $\mathds{F}_{q}^{n}$. 
\end{definicion}

De esta forma, un $[n,k]$-código lineal $\mathcal{C}$ tendrá $q^k$ elementos. Como veremos, la linealidad tiene varias ventajas a la hora de codificar y decodificar de manera más eficiente.

\begin{definicion}
 Una \emph{matriz generadora} para un $[n,k]$-código lineal $\mathcal{C}$ es cualquier matriz $G$ de dimensión $k \times n$ cuyas filas forman una base de $\mathcal{C}$.
\end{definicion}

En general, hay varias matrices generadoras para un código. Un conjunto de información de $\mathcal{C}$ es cualquier conjunto de $k$ columnas linealmente independientes de  $G$. Las demás $r=n-k$ columnas se denominan conjunto redundante y $r$ es la redundancia de $\mathcal{C}$.

Si las primeras $k$ columnas forman un \emph{conjunto de información}, el código tiene una única matriz generadora de la forma $[I_k \ \vert \ A]$, donde $I_k$ es la matriz identidad de dimensión $k$. Se dice que dicha matriz está en \emph{forma estándar}.

Debido a que un código lineal es un subespacio vectorial, sabemos que es el núcleo de una transformación lineal. Esta propiedad da pie a la siguiente definición.

\begin{definicion}
 Una matriz $H$ de dimensión $(n-k) \times n$ es una matriz de paridad para un $[n,k]$-código lineal $\mathcal{C}$ si cumple
  $$\mathcal{C} = \left\{\mathbf{x} \in \mathds{F}_{q}^{n} \ \vert \ H\mathbf{x^T} = 0\right\}. $$ 
\end{definicion}

Nótese que las filas de $H$ también serán linealmente independientes. En general, al igual que ocurría con las matrices generadoras, pueden existir varias matrices de paridad para $\mathcal{C}$. \\ El siguiente teorema nos da una de ellas cuando $\mathcal{C}$ tiene una matriz generadora en forma estándar.

\begin{teorema}\label{th:uno}
Si \ $ G = \left[ I_k \ \vert \ A \right] $  es una matriz generadora para un $[n,k]$-código lineal $\mathcal{C}$ en forma estándar, entonces $H = \left[ - A^T  \ \vert \ I_{n-k} \right]$ es una \emph{matriz de paridad} para $\mathcal{C}$.
\end{teorema}

\begin{proof}
Puesto que $HG^T = -A^T + A^T = 0$, se tiene que $\mathcal{C}$ está contenido en el núcleo de la transformación $\mathbf{x} \rightarrow H\mathbf{x}^T$. Como $H$ tiene rango $n-k$, esta transformación lineal tiene un núcleo de dimensión $k$, que coincide con la dimensión de $\mathcal{C}$. 
\end{proof}

\begin{ejemplo}\label{ej:1.6}
Consideramos la matriz $  G = \left[ I_4 \ \vert \ A \right] $, donde
$$ G = \left[\begin{array}{cccc|ccc}
1&0&0&0&0&1&1\\
0&1&0&0&1&0&1\\
0&0&1&0&1&1&0\\
0&0&0&1&1&1&1\\
\end{array}\right]
$$

es la matriz generadora en forma estándar de un $[7,4]$-código binario $\mathcal{H}_3$. Utilizando el Teorema \ref{th:uno}, una matriz de paridad para $\mathcal{H}_3$ es

$$H = [A^T \ \vert \ I_3] =  \left[\begin{array}{cccc|ccc}
0&1&1&1&1&0&0\\
1&0&1&1&0&1&0\\
1&1&0&1&0&0&1\\
\end{array}\right]. $$

Este código se llama $[7,4]$-\emph{código de Hamming}.

\end{ejemplo}

\subsection{Códigos duales}\label{sec:1.2}

Recordemos que la matriz generadora $G$ de un $[n,k]$-código $\mathcal{C}$ es simplemente una matriz cuyas filas forman una base del código visto como subespacio vectorial. Las filas de una matriz de paridad $H$ también son linealmente independientes y, por tanto, forman una base de algún espacio vectorial. Así, $H$ es la matriz generadora de un código, que llamaremos \emph{ dual u ortogonal} de $\mathcal{C}$ y lo denotaremos como $\mathcal{C}^{\bot}$. Nótese que $\mathcal{C}^{\bot}$ es un $[n,n-k]$-código. 
\\
Una forma alternativa de definir el código dual es usando el producto escalar. Recordemos que el producto escalar de dos vectores $\mathbf{x} = x_1\dots x_n, \mathbf{y} = y_1\dots y_n$ de $\mathds{F}_{q}^{n}$ se define como: $$\mathbf{x} \cdot \mathbf{y} = \sum_{i=1}^{n} x_iy_i.$$ Por tanto, otra definición alternativa es la siguiente.

\begin{definicion}
Dado un $[n,k]$-código $\mathcal{C}$, su \emph{código dual} $\mathcal{C}^{\bot}$ es
$$\mathcal{C}^{\bot} = \left\{ \mathbf{x} \in \mathds{F}_{q}^{n} \ \vert \ \mathbf{x} \cdot \mathbf{c} = 0, \ \forall c \in \mathcal{C} \right\}. $$ 
\end{definicion}

La siguiente proposición caracteriza a las matrices generadoras y de paridad de $\mathcal{C}^{\bot}$ en términos de las de $\mathcal{C}$.

\begin{proposicion}
Si $G$ y $H$ son las matrices generadoras y de paridad de $\mathcal{C}$, respectivamente, entonces $H$ y $G$ son las matrices generadoras y de paridad para $\mathcal{C}^{\bot}$ respectivamente.
\end{proposicion}

\begin{proof}
Se tiene que $$\mathbf{y} \in \mathcal{C}^{\bot} \Leftrightarrow  \mathbf{c} \cdot \mathbf{y} = 0, \forall c \in \mathcal{C} 
\Leftrightarrow (\mathbf{x}G) \cdot \mathbf{y} = 0, \forall \mathbf{x} \in \mathds{F}_{q}^{k} \Leftrightarrow \mathbf{x}G\mathbf{y}^T = 0, \forall \mathbf{x} \in \mathds{F}_{q}^{k} \Leftrightarrow G\mathbf{y}^T = \mathbf{0},$$ donde hemos utilizado que $rg(G) = k$.

Por tanto, $$\mathcal{C}^{\bot} = \left\{ \mathbf{y} \in \mathds{F}_{q}^{n} \ \vert \ G\mathbf{y}^T=\mathbf{0} \right\},$$ luego, $G$ es una matriz de paridad de $\mathcal{C}^{\bot}$.

Veamos ahora que H es una matriz generadora para $\mathcal{C}^{\bot}$. Puesto que $H\mathbf{c}^T = 0,  \forall c \in \mathcal{C}$ (por ser una matriz de paridad para $\mathcal{C}$), cada fila de $H$ está en $\mathcal{C}^{\bot}$. Utilizando que $H$ tiene $n-k$ filas linealmente independientes y $dim(\mathcal{C}^{\bot}) = n-k$, obtenemos que $H$ es una matriz generadora de $\mathcal{C}^{\bot}$.
\end{proof}

\begin{definicion}
Un código $\mathcal{C}$ es auto-ortogonal si $\mathcal{C} \subseteq \mathcal{C}^{\bot}$ y diremos que es auto-dual si $\mathcal{C} = \mathcal{C}^{\bot}$.
\end{definicion}

\begin{proposicion}
Un código auto-dual tiene longitud par y su dimensión es $n/2$.
\end{proposicion}

\begin{proof}
Si un $[n,k]$-código $\mathcal{C}$ tiene dimensión $k$, sabemos que su dual $\mathcal{C}^{\bot}$ tiene dimensión $n-k$. Si suponemos que es auto-dual, entonces $\mathcal{C} = \mathcal{C}^{\bot}$ y, por tanto, $n - k = k$. Así $n = 2k$, $n$ es par y la dimensión de $\mathcal{C}$ es $n/2$.
\end{proof}

\begin{ejemplo}
El $[4,2]$-código ternario $\mathcal{H}_{3,2}$, también llamado tetracódigo, tiene una matriz generadora $G$ en forma estándar dada por

$$G = \left[\begin{array}{cc|cc}
1&0&1&1\\
0&1&1&-1\\
\end{array}\right]. $$
Veamos que este código es auto-dual.

En primer lugar, comprobemos que es auto-ortogonal, es decir, si $\mathcal{C} \subseteq \mathcal{C}^{\bot}$. Dado $\mathbf{c} \in \mathcal{C}$, sabemos que $\mathbf{c}$ pertenece a $\mathcal{C}^{\bot}$ si
$$ G\mathbf{c}^T = \mathbf{0} \Leftrightarrow \mathbf{c}G^T = \mathbf{0}. $$

Así, como $c = xG, x \in \mathds{F}_{q}^{k}$, debemos comprobar que $GG^T = O$.

$$ GG^T = \left[\begin{array}{cccc}
1&0&1&1\\
0&1&1&-1\\
\end{array}\right]
\left[\begin{array}{cc}
1&0\\
0&1\\
1&1\\
1&-1
\end{array}\right]   = O.
$$ 

Por tanto, $\mathcal{H}_{3,2}$ es \emph{auto-ortogonal}. Además, dado que $dim(\mathcal{C}^{\bot}) = 8 - 4 = 4 = dim(\mathcal{C})$, $\mathcal{C}$ es también auto-dual.

\end{ejemplo}

\subsection{Pesos y distancias}\label{sec:1.4}

Al tratar de corregir errores, es esencial establecer algún criterio para medir cuán diferentes son las palabras \emph{transmitidas y las recibidas}. Además, un \emph{invariante} importante de un código $\mathcal{C}$ será la distancia mínima entre palabras código distintas.

\begin{definicion}
  La \emph{distancia de Hamming} $d(\mathbf{x,y})$ entre dos vectores $\mathbf{x,y} \in \mathds{F}_{q}^n$ se define como el número de coordenadas en las que $\mathbf{x}$ e $\mathbf{y}$ difieren.
\end{definicion}
Veamos que efectivamente es una distancia.

\begin{teorema}
  La función distancia $d(\mathbf{x,y})$ de Hamming satisface las siguientes propiedades:
  \begin{enumerate}
    \item[(i)] $d(\mathbf{x,y}) \geq 0 \ \forall \mathbf{x,y} \in \mathds{F}_{q}^n$ (no negatividad).
    \item[(ii)] $d(\mathbf{x,y}) = 0$ \emph{si y solo si} $\mathbf{x} = \mathbf{y}$.
    \item[(iii)] $d(\mathbf{x,y}) = d(\mathbf{y,x}) \ \forall \mathbf{x,y} \in \mathds{F}_{q}^n$ (simetría).
    \item[(iv)] $d(\mathbf{x,z}) \leq d(\mathbf{x,y}) + d(\mathbf{y,z}) \ \forall \mathbf{x,y,z} \in \mathds{F}_{q}^n$ (desigualdad triangular).
  \end{enumerate}
\end{teorema}

\begin{proof}

  Las tres primeras propiedades son evidentes. Veamos que se da la desigualdad triangular. Sean $\mathbf{x,y,z} \in \mathbb{F}_q^n$. Supongamos que $d(\mathbf{x},\mathbf{y}) = r$ y que $d(\mathbf{y},\mathbf{z}) = s$. Por tanto, $\mathbf{x}$ e $\mathbf y$ difieren en $r$ posiciones, digamos $i_1,i_2,\dots,i_r$. Análogamente, $\mathbf{z}$ e $\mathbf{y}$ difieren en las posiciones $j_1,j_2,\dots,j_s$. Entonces, todas las posiciones en las que $\mathbf{x}$ y $\mathbf{z}$ difieran tienen que estar en el conjunto $\{i_1,i_2,\dots,i_r,j_1,j_2,\dots,j_s\}$, que tiene como máximo $r+s$ elementos, lo que nos dice que 
  $$d(\mathbf{x},\mathbf{z}) \leq r + s = d(\mathbf{x},\mathbf{y}) + d(\mathbf{y},\mathbf{z})$$
  
\end{proof}

\begin{ejemplo}
  Sean $\mathbf{x} = 11001001$ e $\mathbf{y} = 11010111$ elementos de $\mathds{F}_{2}^8$, entonces su \emph{distancia de Hamming} es $d(\mathbf{x,y}) = 4$.
\end{ejemplo}

La \emph{distancia mínima} de un código $\mathcal{C}$ es la distancia más pequeña entre palabras código distintas. Es esencial a la hora de determinar la capacidad de corregir errores de $\mathcal{C}$ como veremos en el siguiente teorema. Si la distancia mínima $d$ de un $[n,k]$-código se conoce, nos referiremos al código como un $[n,k,d]$-código.

\begin{teorema}[Decodificación de máxima verosimilitud]\label{th:errores} Sea $\mathcal{C}$ un $[n,k,d]$-código. Entonces, $\mathcal{C}$ puede detectar hasta $d-1$ errores y puede corregir hasta $$ t = \left\lfloor \frac{d-1}{2} \right\rfloor $$

\end{teorema}

\begin{proof}
  Si hay menos de $d$ errores, debido a que la distancia mínima es $d$, no se obtendrá una palabra código, y, por tanto, podemos detectar hasta $d-1$ errores.
  Para la segunda parte, supongamos que se envía una palabra $\mathbf{u}$ y se recibe una palabra $\mathbf{v}$ con, a lo sumo, $t$ errores. Entonces $d(\mathbf{u,v}) \leq t$. Supongamos que existe otra palabra $\mathbf{w} \in \mathcal{C}$ tal que $d(\mathbf{u,w}) \leq t$, entonces utilizando la desigualdad triangular de la distancia de Hamming:
  $$d(\mathbf{v,w}) = d(\mathbf{v,u}) + d(\mathbf{u,w})  \leq 2t \leq d-1.$$
  Esto es una contradicción, puesto que recordemos que $d$ es la distancia mínima entre dos palabras código, por lo que $\mathcal{C}$ puede corregir hasta $t$ errores.
\end{proof}

De esta forma, nos interesará que la \emph{distancia mínima} sea lo mayor posible, con el fin de detectar el mayor número de errores.

Veamos otro concepto interesante relacionado con la distancia de Hamming.

\begin{definicion}
El \emph{peso de Hamming} $wt(x)$ de un vector $\mathbf{x} \in \mathds{F}_{q}^n$ es el número de coordenadas no nulas en $\mathbf{x}$.
\end{definicion}

\begin{ejemplo}
Sea $\mathbf{x} = 1101001$ un elemento de $\mathds{F}_{2}^7$, entonces $wt(\mathbf{x}) = 4$. Nótese que $wt(\mathbf{x}) = d(\mathbf{x,0}) = 4.$
\end{ejemplo}

La relación con la \emph{distancia de Hamming} se sigue del siguiente teorema.

\begin{teorema}\label{th:wp}
Sean $\mathbf{x,y} \in \mathds{F}_{q}^n$, entonces $d(\mathbf{x,y}) = wt(\mathbf{x-y})$. Además, si $\mathcal{C}$ es un código lineal, la distancia mínima $d$ coincide con el mínimo peso de Hamming de una palabra código no nula en $\mathcal{C}$.
\end{teorema}

\begin{proof}
La primera parte de la prueba es inmediata, ya que si tenemos dos elementos distintos, el número de coordenadas en las que difieren es el mismo que el número de coordenadas no nulas al restarlos, esto es $d(\mathbf{x,y}) = d(\mathbf{0,x-y}) = wt(\mathbf{x-y})$.
\\
Para la segunda parte, queremos ver que $$\min_{\mathbf{u,v} \in \mathcal{C}}{d(\mathbf{u,v})} = \min_{\mathbf{w}  \in \mathcal{C^*}}{wt(\mathbf{w})}.$$

Sean $\mathbf{u,v} \in \mathcal{C}$ palabras códigos cuya distancia es mínima, entonces por ser $\mathcal{C}$ un subespacio vectorial, se tiene que $\mathbf{u-v} \in \mathcal{C}$. De esta forma, $d(\mathbf{u,v}) = wt(\mathbf{u-v})$. Por tanto, $$\min_{\mathbf{w}  \in \mathcal{C^*}}{wt(\mathbf{w})} \leq \min_{\mathbf{u,v} \in \mathcal{C}}{d(\mathbf{u,v})}.$$
\\
Por otro lado, sea $\mathbf{w} \in \mathcal{C^*}$ la palabra código cuyo peso de Hamming es mínimo. Así, como $wt(\mathbf{w}) = d(\mathbf{0,w})$ tenemos
$$\min_{\mathbf{u,v} \in \mathcal{C}}{d(\mathbf{u,v})} \leq \min_{\mathbf{w} \in \mathcal{C^*}}{wt(\mathbf{w})}.$$

Y se consigue la igualdad deseada.
\end{proof}

Como consecuencia del teorema anterior, la \emph{distancia mínima} también se conoce como \emph{peso mínimo del código}.

Otra cota importante para códigos lineales es la \emph{cota de Singleton}.

\begin{teorema}[Cota de Singleton]\label{th:cotaS}
Sea $\mathcal{C}$ un $[n,k,d]$-código lineal sobre $\mathbb{F}_q$. Entonces, $$ d \leq n - k + 1.$$
\end{teorema}

\begin{proof}
Recordemos que $\mathcal{C}$ tiene $q^k$ palabras código de longitud $n$. Para cada palabra código $\mathbf{c} = c_1\cdots c_{k-1}\cdots c_n$ consideraremos 
únicamente las primeras $k-1$ componentes. Existen $q^{k-1}$ palabras de longitud $k-1$ en $\mathbb{F}_q^{k-1}$. Dado que tenemos un total de $q^k$ palabras código, deben existir dos palabras código que tengan las primeras $k-1$ componentes iguales. La distancia entre estas dos palabras código es $n - (k-1)$ y, por tanto, $d \leq n - (k - 1) = n - k + 1$.
\end{proof}

Los códigos que alcancen la cota de Singleton se denominan códigos MDS (máxima distancia separable).

\begin{definicion}
  Sea $A_i\mathcal{(C)}$ el número de palabras código de peso $i$ en $\mathcal{C}$. Para cada $0 \leq i \leq n$, la lista $A_i(\mathcal{C})$ se denomina \emph{distribución de pesos o espectro de pesos} de $\mathcal{C}$.
\end{definicion}

Una gran parte de la investigación en teoría de códigos ha sido el cálculo de la distribución de pesos de códigos específicos o de familias de códigos conocidas.

\begin{ejemplo}
Vamos a calcular la distribución de pesos del código binario $\mathcal{C}$ con la siguiente matriz generadora:
$$G = \left[\begin{array}{cccccc}
  1&1&0&0&0&0\\
  0&0&1&1&0&0\\
  0&0&0&0&1&1\\
  \end{array}\right]. $$

  Sea $\mathbf{x} = (x_1,x_2,x_3) \in \mathds{F}_{2}^3$. Entonces, 
  $$(x_1,x_2,x_3)\left[\begin{array}{cccccc}
    1&1&0&0&0&0\\
    0&0&1&1&0&0\\
    0&0&0&0&1&1\\
    \end{array}\right] = (x_1,x_1,x_2,x_2,x_3,x_3). $$

  y las palabras código serán las siguientes:

  $$ 000 \rightarrow 000000, \quad		001 \rightarrow 000011, \quad			010 \rightarrow 001100, \quad			011 \rightarrow 001111,$$
  $$ 100 \rightarrow 110000, \quad		101 \rightarrow 110011, \quad			110 \rightarrow 111100, \quad			111 \rightarrow 11111.$$

  Así, $\mathcal{C} = \{000000,000011,001100,001111,110000,110011,111100,11111\}$.

  Se tiene que la distribución de pesos es $A_0(\mathcal{C}) = A_6(\mathcal{C}) = 1 $, $A_2(\mathcal{C}) = A_4(\mathcal{C}) = 3 $. Normalmente, solo se listan los $A_i$ no nulos.
\end{ejemplo}

Algunos hechos elementales acerca de las \emph{distribuciones de pesos} están recogidos en el siguiente teorema.

\begin{teorema}
Sea $\mathcal{C}$ un $[n,k,d]$-código lineal sobre $\mathds{F}_q$. Entonces:
\begin{enumerate}
  \item[(i)] $A_0(\mathcal{C}) + A_1(\mathcal{C}) + \cdots + A_n(\mathcal{C}) = q^k$.
  \item[(ii)] $A_0(\mathcal{C}) = 1$ y $A_1(\mathcal{C}) = A_2(\mathcal{C}) = \cdots = A_{d-1}(\mathcal{C}) = 0$.
  \item[(iii)] Si $\mathcal{C}$ es un código binario que contiene la palabra código $\mathbf{1} = 11\cdots 1$, entonces $A_i(\mathcal{C}) = A_{n-i}(\mathcal{C})$ para $i \in \{0,\dots,n\}$.
\end{enumerate}
\end{teorema}

\begin{proof}
  \hphantom \\
  \begin{itemize} 
  \item La propiedad \textit{(i)} es evidente. Recordemos que el número total de palabras de un $[n,k]$-código lineal sobre $\mathds{F}_q$ es $q^k$, y el peso de cada una de las palabras va de $0$ hasta $n$.
  \item Para la propiedad \textit{(ii)}  sabemos que $A_0(\mathcal{C}) = 1$, ya que $\mathbf{0} \in \mathcal{C}$ (por ser un subespacio vectorial), como consecuencia, si se diese que $A_i(\mathcal{C}) \neq 0$ para algún $i \in \{1,\dots,d-1\}$ existiría una palabra cuyo peso es menor que $d-1$, pero entonces su distancia de Hamming respecto a $\mathbf{0}$ sería menor que $d$ lo que contradice la propia definición de $d$.
  \item Por último, veamos la propiedad \textit{(iii)} . Puesto que $\mathcal{C}$ es un subespacio vectorial y $\mathbf{1} \in \mathcal{C}$ se tiene que si $\mathbf{c} \in \mathcal{C}$, entonces  $\mathbf{1-\mathbf{c}} \in \mathcal{C}$. Obsérvese que $wt(\mathbf{1-c}) = n - wt(\mathbf{c})$. De esta manera, para cada palabra código $\mathbf{c}$ de peso $i$ existirá otra palabra código $\mathbf{1-c}$ de peso $n-i$, lo que concluye la demostración.
  \end{itemize}
\end{proof}

\subsection{Codificación de códigos lineales}\label{sec:1.3}

Sea $\mathcal{C}$ un $[n,k]$-código lineal sobre el cuerpo $\mathds{F}_{q}$ con matriz generadora $G$. Sabemos que este código tiene $q^k$ palabras código, que podemos hacer corresponder con $q^k$ mensajes.

La manera más simple de ver un mensaje es como una $k$-tupla $\mathbf{m}\in \mathds{F}_{q}^k.$ Este mensaje lo codificaremos como la palabra código $\mathbf{c} = \mathbf{m}G$. Si $G$ está en forma estándar, las primeras $k$ coordenadas de la palabra código $\mathbf{c}$ son los símbolos de información $\mathbf{m}$,mientras que los $n-k$ símbolos restantes serán los símbolos de paridad, que son símbolos redundantes añadidos a $\textbf{m}$ que nos ayudarán a recuperar el mensaje si ocurre algún error.

\begin{ejemplo}\label{ej:1.12}

  Sea $\mathcal{C}$ un $[6,3]$-código binario lineal con la siguiente matriz generadora:
  $$ G = \left[\begin{array}{cccccc}
    1&0&0&1&0&1\\
    0&1&0&1&1&0\\
    0&0&1&0&1&1\\
    \end{array}\right].
    $$
Dado un mensaje $\mathbf{m} = (x_1,x_2,x_3) \in \mathds{F}_{2}^3$ lo codificamos utilizando la matriz generadora $G$.
$$ (x_1,x_2,x_3) \left[\begin{array}{cccccc}
  1&0&0&1&0&1\\
  0&1&0&1&1&0\\
  0&0&1&0&1&1\\
  \end{array}\right] = (x_1,x_2,x_3,x_1 + x_2,x_2 + x_3,x_1 + x_3).$$

  Así, este código codifica de la siguiente forma: 

  $$ 000 \rightarrow 000000, \quad		001 \rightarrow 001011, \quad			010 \rightarrow 010110, \quad			011 \rightarrow 011101,$$
  $$ 100 \rightarrow 100101, \quad		101 \rightarrow 101110, \quad			110 \rightarrow 110011, \quad			111 \rightarrow 111000.$$

  Por tanto, $\mathcal{C} = \{000000,001011,010110,011101,100101,101110,110011,111000\}$.
\end{ejemplo}




Puede darse que la matriz generadora $G$ no esté en forma estándar, sin embargo, si existiera un conjunto de índices $i_1,i_2,\dots,i_k$ correspondientes a las columnas de la matriz $G$, de manera que la matriz $k \times k$ formada por esas $k$ columnas de $G$ es igual a $I_k$, se dice que la codificación es \emph{sistemática}. Equivalentemente, una codificación es \emph{sistemática} cuando el mensaje se encuentra incrustado íntegramente en el código (aunque sea de forma desordenada). Se observa que la codificación en el Ejemplo \ref{ej:1.12} es sistemática, ya que las tres primeras coordenadas del mensaje codificado corresponden con el mensaje original.
\\
Sin embargo, no todas las codificaciones son sistemáticas.

\begin{ejemplo}\label{ej:1.13}

    Sea $\mathcal{C}$ un $[2,4]$-código binario lineal cuya matriz generadora es
    $$ G = \left[\begin{array}{cccc}
      1&0&0&1\\
      1&1&1&1\\
      \end{array}\right].
      $$
  Dado un mensaje $\mathbf{m} = (x_1,x_2) \in \mathds{F}_{2}^2$ lo codificamos utilizando la matriz generadora $G$.
  $$ (x_1,x_2,x_3) \left[\begin{array}{cccc}
    1&0&0&1\\
    1&1&1&1\\
    \end{array}\right] = (x_1 + x_2,x_2,x_2,x_1 + x_2).$$

    Entonces, este código codifica de la siguiente forma: 

  $$ 00 \rightarrow 0000, \quad		01 \rightarrow 1111, \quad			10 \rightarrow 1001, \quad			11 \rightarrow 0110.$$

  Por tanto, $\mathcal{C} = \{0000,1111,1001,0110\}$.
\end{ejemplo}

Observamos en el Ejemplo \ref{ej:1.13} que no existe ningún conjunto de índices $i_1,i_2$ correspondientes a las columnas de la matriz $G$, de manera que esas columnas formen la matriz identidad $I_2$. Además, la codificación del mensaje $01$ es $1111$ que no contiene al mensaje original. Cuando esto ocurre se dice que la codificación es \emph{no sistemática}.

Acabamos de ver un método para codificar un mensaje $\mathbf{m}$ utilizando la matriz generadora de un código $\mathcal{C}$. En ocasiones, también es posible utilizar la matriz de paridad $H$ para este mismo fin. La forma más simple de hacerlo es cuando la matriz $G$ está en forma estándar $[I_k \ \vert \ A]$. En este caso,  el Teorema \ref{th:uno} nos asegura que $H = \left[ - A^T  \ \vert \ I_{n-k} \right]$. Supongamos que un mensaje $\textbf{m} = x_1\cdots x_k$ se codifica en la palabra código $c = c_1\cdots c_n$. Como $G$ está en forma estándar, $c_1\cdots c_k = x_1\cdots x_k$. Por tanto, necesitamos determinar los $n-k$ símbolos de paridad (símbolos redundantes) \ $c_{k+1}\cdots c_n$. Puesto que $\mathbf{0} = H\mathbf{c}^T = \left[ - A^T  \ \vert \ I_{n-k} \right]\mathbf{c}^T, A^T\mathbf{m}^T = [c_{k+1}\cdots c_n]^T$. Este método se puede generalizar cuando $G$ es un codificador sistemático.

\begin{ejemplo}
  Sea $\mathcal{C}$ el mismo código binario que en el Ejemplo \ref{ej:1.12}. Podemos utilizar el Teorema \ref{th:uno} para encontrar la matriz de paridad $H$ (puesto que $G$ está en forma estándar). Así, 
  $$ H = \left[\begin{array}{cccccc}
    1&1&0&1&0&0\\
    0&1&1&0&1&0\\
    1&0&1&0&0&1\\
    \end{array}\right].
    $$
  
  Recordemos que el ejemplo anterior, habíamos obtenido que dado un mensaje $\mathbf{m} = (x_1,x_2,x_3) \in \mathds{F}_{2}^3$, su codificación era la palabra código $\mathbf{c} = c_1\cdots c_n = \mathbf{m}G = (x_1,x_2,x_3,x_1 + x_2,x_2 + x_3,x_1 + x_3)$.

  Seguimos el proceso descrito para codificar $\mathbf{m}$ a partir de $H$. Puesto que $\mathbf{0} = H\mathbf{c}$, obtenemos el siguiente sistema:
   \begin{equation*}
      \begin{cases}
        c_1 + c_2 + c_4 = 0,\\
        c_2 + c_3 + c_5 = 0,\\
        c_1 + c_3 + c_6 = 0.
      \end{cases}
    \end{equation*}
  Como $G$ está en forma estándar, $c_1 c_2 c_3 = x_1 x_2 x_3$ y resolviendo este sistema, obtenemos la misma palabra código que con la matriz generadora.

  
\end{ejemplo}

Debido a la correspondencia uno a uno entre mensajes y palabras código, a veces nos puede interesar obtener el mensaje $\textbf{m}$ a partir de la palabra código $\textbf{c}$ mediante un proceso inverso a la codificación. Supongamos que $\mathbf{c} = \mathbf{m}G$. Si $G$ está en forma estándar, será fácil recuperar el mensaje original, simplemente tendremos que quedarnos con las primeras $k$ componentes de $\mathbf{c}$. Si $G$ no está en forma estándar, al existir una biyección entre las palabras código y los mensajes, existirá una matriz $K$ de dimensión $n \times k$ de manera que $GK = I_k$. Llamaremos a $K$ la \emph{inversa por la derecha de $G$}, la cual no es necesariamente única. De esta forma, puesto que $\mathbf{c} = \mathbf{m}G$, $\mathbf{c}K = \mathbf{m}GK = \mathbf{m}$ y se podrá recuperar el mensaje original.

\begin{ejemplo}

  Sea $\mathcal{C}$ un $[7,3]$-código lineal dado por la matriz generadora

  $$ G = \left[\begin{array}{ccccccc}
    1&0&1&1&0&1&1\\
    1&1&0&1&0&1&0\\
    0&0&1&1&1&1&0\\
    \end{array}\right].
    $$
  
 Codificamos el mensaje $\mathbf{m} = 110$ con el procedimiento visto anteriormente. Así, $\mathbf{c} = \mathbf{m}G = 0110001$.

  Si queremos obtener el mensaje $\mathbf{m}$ a partir de $\mathbf{c}$, en primer lugar calculamos la matriz inversa por la derecha de $G$, que en este caso es

  $$ K = \left[\begin{array}{ccc}
    1&0&1\\
    1&1&1\\
    0&0&1\\
    0&0&0\\
    0&0&0\\
    0&0&0\\
    0&0&0\\
    \end{array}\right].
    $$
  Así, el mensaje original vendrá dado por $$\mathbf{c}K = (0,1,1,0,0,0,1)\left[\begin{array}{ccc}
    1&0&1\\
    1&1&1\\
    0&0&1\\
    0&0&0\\
    0&0&0\\
    0&0&0\\
    0&0&0\\
    \end{array}\right] = (1,1,0) = \mathbf{m}.$$
\end{ejemplo}

\section{Códigos cíclicos}

En esta sección estudiaremos una clase destacada de códigos: los \emph{códigos cíclicos}. Estos códigos fueron introducidos en el año 1957 por Eugene Prange en \cite{prange1957cyclic}, que se percató de que los códigos cíclicos tenían una rica estructura algebraica. Esto sugirió que el álgebra podía desempeñar un papel crucial en la teoría de códigos. Los códigos cíclicos fueron unos de los primeros códigos usados en la práctica, ya que era fácil implementarlos utilizando registros de desplazamiento.
La principal fuente consultada para esta sección ha sido \cite{Huffman_Pless_2010}.

\begin{definicion}
Un código lineal $\mathcal{C}$ de longitud $n$ sobre $\mathbb{F}_q$ es \emph{cíclico} si para cada palabra código $\mathbf{c} = c_0\cdots c_{n-2}c_{n-1}$ en $\mathcal{C}$, el vector $c_{n-1}c_0\cdots c_{n-2}$, obtenido mediante un desplazamiento cíclico de $\mathbf{c}$, llevando $i \rightarrow i+1$ mod $n$, está también en $\mathcal{C}$.
\end{definicion}

Por tanto, dado un elemento $\mathbf{c}$ de un código cíclico $\mathcal{C}$, se tiene que los $n$ desplazamientos cíclicos de $\mathbf{c}$ también están en $\mathcal{C}$.

Normalmente, al estudiar los códigos cíclicos sobre $\mathbb{F}_q$ representaremos las palabras código en forma polinomial. Esto se debe a que existe una correspondencia biyectiva entre los vectores $\mathbf{c} = c_1\cdots c_{n-1} \in \mathbb{F}_{q}^n$ y los polinomios $c(x) = c_0 + c_1x + \cdots c_{n-1}x^{n-1} \in \mathbb{F}_q[x]$ de grado máximo $n-1$. Nótese que si $c(x) =  c_0 + c_1x + \cdots c_{n-1}x^{n-1}$, entonces $xc(x) =  c_{n-1}x^{n} + c_0x + c_1x^2 + \cdots c_{n-2}x^{n-1}$, que representaría a la palabra código $\mathbf{c}$ desplazada cíclicamente una posición a la derecha si $x^n$ fuese igual a $1$. 

Formalmente, el hecho de que un código $\mathcal{C}$ sea invariante bajo un desplazamiento cíclico, implica que si $c(x)$ está en $\mathcal{C}$, entonces $xc(x)$ también lo está, siempre que multipliquemos módulo $x^n-1$. Esto nos sugiere que el contexto adecuado para el estudio de los códigos cíclicos es el anillo cociente $$\mathcal{R}_n = \mathbb{F}_q[x]/\langle x^n-1 \rangle.$$
De esta manera, bajo la correspondencia de vectores con polinomios descrita anteriormente, los códigos cíclicos son \emph{ideales} de $\mathcal{R}_n$ y los ideales de $\mathcal{R}_n$ son códigos cíclicos. Así, el estudio de los códigos cíclicos en $\mathbb{F}_{q}^n$ es equivalente al estudio de los ideales en $\mathcal{R}_n$, que depende de la factorización de $x^n-1$, que estudiaremos a continuación.



\subsection{Factorización de $x^n-1$}

Nuestro primer objetivo será encontrar los factores irreducibles de $x^n-1$ sobre $\mathbb{F}_q$. Existen dos posibilidades: que $x^n-1$ tenga factores irreducibles repetidos o que no los tenga. Para el estudio de los códigos cíclicos nos centraremos en la segunda posibilidad. La siguiente proposición nos da una condición para que $x^n-1$ sobre $\mathbb{F}_q$ no tenga factores irreducibles repetidos.

\begin{proposicion}
Equivalen las siguientes afirmaciones:
\begin{enumerate}
    \item[(i)]$x^n-1$ no tiene factores irreducibles repetidos en $\mathbb{F}_q$.
    \item[(ii)] $mcd(q,n) = 1$.
\end{enumerate}
\end{proposicion}

\begin{proof}
   \phantom{a}\\ \\ \boxed{\text{\textit{(i)}} \Rightarrow \text{\textit{(ii)}}} 

    Supongamos que $x^n-1$ no tiene factores irreducibles repetidos sobre $\mathbb{F}_q$. Por reducción al absurdo, si $mcd(q,n) \neq 1$, entonces $n = q^em$ para algún $e > 0$, $q \nmid m$. De esta forma, 
    $$x^n - 1 = x^{q^em} - 1 = (x^{m})^{q^e} - 1 = (x^m - 1)^{q^e},$$ que claramente tiene factores irreducibles repetidos, lo cual supone una contradicción. Se ha utilizado la Proposición \ref{prop:bin}.
    \phantom{a}\\ \\ \boxed{\text{\textit{(ii)}} \Rightarrow \text{\textit{(i)}}} 

    Supongamos ahora que $mcd(q,n) = 1$. Sea $I$ el ideal de $\mathbb{F}_q[x]$ generado por los elementos $x^n - 1$ y $nx^{n-1}$. Por hipótesis, como $mcd(q,n) = 1$ se tiene que $n$, visto como un elemento de $\mathbb{F}_q$, es una unidad. Por tanto,

    $$nx^{n-1} \in I \Rightarrow x^{n-1} \in I \Rightarrow x^{n} \in I \Rightarrow x^n - (x^n - 1) \in I \Rightarrow 1 \in I \Rightarrow I = (1) =\mathbb{F}_q[x] .$$

    Por tanto, se tiene que en $\mathbb{F}_q[x]$, $mcd(x^n-1,nx^{n-1}) = 1$, ya que el ideal generado por ambos es el trivial. Recordemos que un polinomio $f\in \mathbb{F}_q[x]$ no tiene factores irreducibles repetidos si y solo si $mcd(f,f') = 1$. Utilizando este último resultado, donde $f = x^n - 1$, se concluye la demostración.

\end{proof}

Para factorizar $x^n - 1$ sobre $\mathbb{F}_q$ necesitamos encontrar una extensión de cuerpos $\mathbb{F}_{q^t}$ que contenga todas sus raíces. Dicho de otra forma, $\mathbb{F}_{q^t}$ debe contener una \emph{raíz n-ésima primitiva de la unidad}, que en virtud del Teorema \ref{th:ep}, esto ocurrirá si y solo si $ n \ | \ (q^t - 1)$. En tal caso, $\gamma^{(q^t - 1)/n}$ es dicha raíz.


\begin{definicion}
    El \emph{orden} de $q$ módulo $n$, denotado por $ord_n(q)$,  es el menor entero positivo $a$ tal que $q^a \equiv 1$ (mod $n$).
\end{definicion}

Nótese que si $t = ord_n(q)$, entonces $\mathbb{F}_{q^t}$ contiene una raíz n-ésima primitiva de la unidad $\alpha$, puesto que por la definición de orden, $q^t \equiv 1$ (mod $n$) $\Leftrightarrow n \ | \ (q^t - 1)$. Además, ninguna extensión de cuerpos más pequeña contendrá una raíz primitiva de la unidad, al ser $t$ el menor entero que cumple dicha condición. Como los $\alpha^i$ son distintos para $i \in \{0,\dots, n\}$ y $(\alpha^i)^n = 1$, $\mathbb{F}_{q^t}$ contiene todas las raíces de $x^n - 1$. En consecuencia, $\mathbb{F}_{q^t}$ es un \emph{cuerpo de descomposición} \footnote{Es decir, un cuerpo donde $x^n-1$ se factoriza mediante polinomios de grado uno.} de $x^n - 1$ sobre $\mathbb{F}_{q}$. De esta manera, los factores irreducibles de $x^n - 1$ sobre $\mathbb{F}_{q}$ deben ser el producto de los distintos polinomios minimales de las n-ésimas raíces de la unidad en $\mathbb{F}_{q^t}$. Supongamos que $\gamma$ es un elemento primitivo de $\mathbb{F}_{q^t}$. Entonces $\alpha = \gamma^d$ es una raíz n-ésima primitiva de la unidad, donde $d = (q^t - 1)/n$. Las raíces de $M_{\alpha^s}(x)$ son $$\{\gamma^{ds},\gamma^{dsq},\dots,\gamma^{dsq^{r-1}}\} = \{\alpha^s,\alpha^{sq},\dots,\alpha^{sq^{r-1}}\},$$ donde $r$ es el entero positivo más pequeño tal que $dsq^r \equiv ds \ \text{  (mod $q^t-1$)}$ por el Teorema \ref{th:1.ult}. Pero $dsq^r \equiv ds \ \text{  (mod $q^t-1$)}$ si y solo si $sq^r \equiv s \ \text{  (mod $n$)}$.

Esto nos lleva a extender la definición de clases $q$-ciclotómicas desarrolladas en la Sección \ref{sec:ciclo}.

Sea $s$ un entero, con $s \in \{0,\dots,n-1\}$. La clase $q$-ciclotómica de $s$ módulo $n$ es el conjunto
$$C_s = \{s,sq,\dots,sq^{r-1}\} \ \ \text{(mod }n),$$
donde $r$ es el entero positivo más pequeño tal que $sq^r \equiv s \ \ \text{(mod n)}$. En la Sección \ref{sec:ciclo} habíamos estudiado un caso más restrictivo, donde $n = q^t - 1$. Sin embargo, este concepto puede generalizarse a un $n$ arbitrario.

\begin{teorema}\label{th:fac}
Sea $n$ un entero positivo coprimo con $q$. Sea $t = ord_n(q)$. Sea $\alpha$ una $n$-ésima raíz primitiva de la unidad en $\mathbb{F}_{q^t}$.
\begin{itemize}
    \item[(i)] Para cada entero $s \in \{0,\dots,n-1\}$, el polinomio minimal de $\alpha^s$ en $\mathbb{F}_q$ es $$M_{\alpha^s}(x) = \prod_{i \in C_s}(x - \alpha^i), $$
    donde $C_s$ es la clase $q$-ciclotómica de $s$ módulo $n$.
    \item[(ii)] Los conjugados\footnote{Recordemos que dos elementos  son conjugados en $\mathbb{F}_{q}$ si tienen el mismo polinomio minimal en $\mathbb{F}_{q}[x]$.} de $\alpha^s$  son los elementos $\alpha^i$ con $i \in C_s$.
    \item[(iii)] Además, $$x^n - 1 = \prod_{s}M_{\alpha^s}(x)$$ es la factorización de $x^n - 1$ en factores irreducibles en $\mathbb{F}_q$, donde $s$ varía en un conjunto de representantes de las clases $q$-ciclotómicas módulo n.
\end{itemize}
\end{teorema}

\subsection{Teoría básica de códigos cíclicos}

Recordemos que los códigos cíclicos sobre $\mathbb{F}_q$ son precisamente los ideales de

$$\mathcal{R}_n = \mathbb{F}_q[x]/\langle x^n-1 \rangle.$$

La Proposición \ref{prop:dip} nos afirmaba que $\mathbb{F}_q[x]$ era un dominio de ideales principales. Veremos más adelante que los ideales de $\mathcal{R}_n$ también son principales, y, por tanto, los códigos cíclicos son los ideales principales de $\mathcal{R}_n$.

La manera más formal de escribir un código cíclico es como un elemento $c(x) + (x^n - 1)$ del ideal $\mathcal{R}_n$. Sin embargo, para simplificar la notación escribiremos $c(x)$. Así, pensaremos en los elementos de $\mathcal{R}_n$ como polinomios en $\mathbb{F}_q[x]$ en los que los términos de la forma $ax^{ni+j}$, $ j \in \{0,\dots,n-1\}, \ i \in \mathds{N}$, se cambiarán por $ax^j$. 

Para distinguir el ideal principal $(g(x))$ de $\mathbb{F}_q[x]$ del mismo ideal en $\mathcal{R}_n$, usaremos la notación $\langle g(x) \rangle$ para el ideal de $\mathcal{R}_n$ generado por $g(x)$. 

El siguiente teorema nos permitirá describir los códigos cíclicos, ya que nos afirma que hay una correspondencia biyectiva entre los códigos cíclicos en $\mathcal{R}_n$ y los polinomios mónicos que dividen a $x^n - 1$.

\begin{teorema}\label{th:ci}
Sea $\mathcal{C}$ un código cíclico no nulo en $\mathcal{R}_n$. Entonces existe un polinomio $g(x) \in \mathcal{C}$ que verifica las siguientes propiedades:
\begin{itemize}
    \item[(i)] $g(x)$ es el único polinomio mónico de grado mínimo en $\mathcal{C}$.
    \item[(ii)] El polinomio $g(x)$ genera $\mathcal{C}$. Es decir, $\mathcal{C} = \langle g(x) \rangle.$
    \item[(iii)] El polinomio $g(x)$ divide a $x^n-1$.
\end{itemize}
Sea $k = n- \gr(g(x))$ y sea $g(x) = \sum_{i=0}^{n-k}g_ix^i$ donde $g_{n-k} = 1$. Entonces:
\begin{itemize}
    
    \item[(iv)] La dimensión de $\mathcal{C}$ es $k$ y $\{g(x),xg(x),\dots,x^{k-1}g(x)\}$ es una base de $\mathcal{C}$.
    \item[(v)] Todo elemento de $\mathcal{C}$ se puede escribir de manera única como el producto de $g(x)f(x)$, donde $f(x) = 0$ o $\gr(f(x)) < k$.
    \item[(vi)] Una matriz generadora de $\mathcal{C}$ es
    
    $$ G =
    \left[\begin{array}{ccccccc}
    g_0 & g_1 & \cdots & g_{n-k} & & & \bigcirc \\
     & g_0 & g_1 & \cdots & g_{n-k} & & \\
     & & \ddots & \ddots & & \ddots & \\
    \bigcirc & & & g_0 &g_1 & \cdots &g_{n-k}
    \end{array}
    \right],
    $$

    donde cada fila es un desplazamiento cíclico de la fila anterior.


    \item[(vii)] Si $\alpha$ es una raíz $n$-ésima primitiva de la unidad en alguna extensión de $\mathbb{F}_q$, entonces  $$g(x) = \prod_{s}M_{\alpha^s}(x),$$
    siendo el producto sobre un subconjunto de representaciones de las clases $q$-ciclotómicas módulo $n$.
\end{itemize}
\end{teorema}

\begin{proof}
    \phantom{} \\ \\  \boxed{\textit{(i) y (ii)}} \\ \\ Sea $g(x)$ un polinomio mónico de grado mínimo en $\mathcal{C}$, que existe por ser $\mathcal{C}$ no nulo. Si $c(x) \in \mathcal{C}$, entonces, por el algoritmo de la división en $\mathbb{F}_q[x]$ \ref{prop:div}, $c(x) = g(x)h(x) + r(x)$, donde o bien $r(x) = 0$ o \ $\gr(r(x)) < \gr(g(x))$. Como $\mathcal{C}$ es un ideal de $\mathcal{R}_n$, $r(x) \in \mathcal{C}$ y al tener $g(x)$ grado mínimo, se deduce que $r(x) = 0$. Por tanto, $\mathcal{C} = \langle g(x) \rangle$, lo que prueba \textit{(ii)}. Si existiese otro polinomio $q(x)$ mónico de grado mínimo en $\mathcal{C}$ se tiene que $q(x) = g(x)h(x)$. Como $q(x)$ es mónico y del mismo grado que $g(x)$ necesariamente $h(x) = 1$ y, por tanto, $g(x) = q(x)$, lo que prueba \textit{(i)}.

    \boxed{\textit{(iii)}} \\ \\ Utilizando de nuevo el algoritmo de la división, $x^n - 1 = g(x)h(x) + r(x)$, donde $r(x) = 0$ o $\gr(r(x)) < \gr(g(x))$. Como en $\mathcal{R}_n$ se verifica que $x^n - 1 = 0 \in \mathcal{C}$, se tiene que $r(x) \in \mathcal{C}$, lo que es una contradicción a menos que $r(x) = 0$. En consecuencia, $ g(x) \ | \ x^n - 1$.

    \boxed{\textit{(iv) y (v)}} \\ \\
    Supongamos que $\gr(g(x)) = n-k$. Por los apartados \textit{(ii) y (iii)}, si $c(x) \in \mathcal{C}$ con $c(x) = 0$ o $\gr(c(x)) < n$, entonces $c(x) = g(x)f(x)$ para algún polinomio $f(x)$ en $\mathbb{F}_q[x]$. Si $c(x) = 0$, $f(x) = 0$. Por otro lado, $\gr(c(x)) < n$ implica que $\gr(f(x)) < k$. Entonces,  $$\mathcal{C} = \{g(x)f(x) \ | \ f(x) = 0 \text{ ó } \gr(f(x)) < k\}.$$
    Por tanto, $\mathcal{C}$ tiene dimensión al menos $k$ y $\{g(x),xg(x),\dots,x^{k-1}g(x)\}$ es un sistema de generadores de $\mathcal{C}$. Como estos $k$ polinomios tienen grados diferentes, son independientes en $\mathbb{F}_q[x]$. Además, tienen un grado estrictamente menor que $n$ y, por tanto, permanecen iguales en $\mathcal{R}_n$. Esto prueba que $\{g(x),xg(x),\dots,x^{k-1}g(x)\}$ es una base de $\mathcal{C}$ y que su dimensión es exactamente $k$, lo que nos lleva a \textit{(iv)}. De la unicidad de $g(x)$ se obtiene que la descomposición $c(x) = g(x)f(x)$ es única, lo que prueba \textit{(v)}.

    \boxed{\textit{(vi)}} \\ \\
    La matriz $G$ es matriz generadora de $\mathcal{C}$, ya que $\{g(x),xg(x),\dots,x^{k-1}g(x)\}$ es una base de $\mathcal{C}$.

    \boxed{\textit{(vii)}} \\ \\
    Se deduce del Teorema \ref{th:fac} y de \textit{(iii)}.
\end{proof}

Observemos que \textit{(ii)} prueba que $\mathcal{R}_n$ es un dominio de ideales principales, pues todos sus ideales (es decir, los códigos cíclicos) pueden ser generados por un único elemento. 

\begin{corolario}\label{col:ci}
Sea $\mathcal{C}$ un código cíclico no nulo en $\mathcal{R}_n$. Equivalen las siguientes afirmaciones;
\begin{itemize}
    \item[(i)] $g(x)$ es el polinomio mónico de menor grado en $\mathcal{C}$.
    \item[(ii)]  $\mathcal{C} = \langle g(x) \rangle$, $g(x)$ es mónico y divide a $x^n - 1$.
\end{itemize}
\end{corolario}

\begin{proof}
\phantom{} \\
\boxed{\textit{(i) $\Rightarrow$ \textit{(ii)}}} Probado en el Teorema \ref{th:ci}.


\boxed{\textit{(ii) $\Rightarrow$ \textit{(i)}}} \\

Sea $g_1(x)$ el polinomio mónico de menor grado en $\mathcal{C}$. Como se ha visto en la demostración del Teorema \ref{th:ci}, $g_1(x) \ | \ g(x)$ en $\mathbb{F}_q[x]$ y $\mathcal{C}= \langle g_1(x) \rangle $. Puesto que $g_1(x) \in \mathcal{C} = \langle g(x) \rangle$, se tiene que
$$ g_1(x) \equiv g(x)a(x) \text{   (mod  } x^n - 1).$$ 
También se tiene que $g_1(x) = g(x)a(x) + (x^n - 1)b(x)$ en $\mathbb{F}_q[x]$. Dado que $g(x) \ | \ (x^n - 1)$, entonces $g(x)$ divide a $g_1(x)$. Teniendo en cuenta que tanto $g_1(x)$ como $g(x)$ son mónicos y se dividen mutuamente en $\mathbb{F}_q[x]$, necesariamente son iguales.

\end{proof}

El Teorema \ref{th:ci} nos dice que existe un polinomio mónico $g(x)$ que divide a $x^n - 1$ y genera $\mathcal{C}$. El Corolario \ref{col:ci} asegura que $g(x)$ es único. A este polinomio le llamamos \emph{el polinomio generador} del código cíclico $\mathcal{C}$. Por el Corolario \ref{col:ci}, este polinomio es tanto el polinomio mónico en $\mathcal{C}$ de menor grado, como el polinomio mónico que divide a $x^n - 1$ y genera $\mathcal{C}$. Por tanto, existe una biyección entre los códigos cíclicos no nulos y los divisores propios\footnote{Entendemos por divisores propios de un polinomio al conjunto de todos sus divisores salvo él mismo.} de $x^n-1$. Para obtener la biyección entre el conjunto de los códigos cíclicos en $\mathcal{R}_n$ y el conjunto de divisores mónicos de $x^n - 1$,definimos el polinomio generador del código cíclico nulo $\{\mathbf{0}\}$ como $x^n - 1$, es decir, $\langle x^n - 1 \rangle = \{\mathbf{0}\}$ (recordemos que $x^n - 1 = 0$ en $\mathcal{R}_n$). Esta biyección nos conduce al siguiente corolario.

\begin{corolario}
El número de códigos cíclicos en $\mathcal{R}_n$ es igual a $2^m$, siendo $m$ el número de clases $q$-ciclotómicas módulo $n$.
\end{corolario}

Por tanto, si $g(x)$ es un polinomio de grado $n-k$ que divide a $x^n - 1$ en $\mathbb{F}_q[x]$, generará un $[n,k]$-código cíclico. Veamos un ejemplo de algún código cíclico.

\begin{ejemplo}
Dado el polinomio $x^9 - 1$, podemos factorizarlo en polinomios irreducibles en $\F_2[x]$ como $x^9 - 1 = (1 + x)(1 + x + x^2)(1 + x^3 + x^6)$.

Todos los divisores de $x^9 - 1$ generarán un código cíclico. En particular, veamos los códigos cíclicos $ \langle 1 + x\rangle$ y $ \langle 1 + x + x^2 \rangle$.

\begin{itemize}
    \item $\langle 1 + x \rangle:$ La dimensión del código es $k = 9 - 1 = 8$ y este polinomio genera un $[9,8]$-código cíclico. Haciendo uso del Teorema \ref{th:ci} podemos obtener la matriz generadora del código:
    $$ G = \left[\begin{array}{ccccccccc}
        1&1&0&0&0&0&0&0&0\\
        0&1&1&0&0&0&0&0&0\\
        0&0&1&1&0&0&0&0&0\\
        0&0&0&1&1&0&0&0&0\\
        0&0&0&0&1&1&0&0&0\\
        0&0&0&0&0&1&1&0&0\\
        0&0&0&0&0&0&1&1&0\\
        0&0&0&0&0&0&0&1&1\\
    \end{array}\right].$$
    \item $\langle 1 + x + x^2 \rangle:$ La dimensión del código es $k = 9 - 2 = 7$. Por tanto, este polinomio genera un $[9,8]$-código cíclico. Haciendo uso del Teorema \ref{th:ci} podemos obtener la matriz generadora del código:
    $$ G = \left[\begin{array}{ccccccccc}
        1&1&1&0&0&0&0&0&0\\
        0&1&1&1&0&0&0&0&0\\
        0&0&1&1&1&0&0&0&0\\
        0&0&0&1&1&1&0&0&0\\
        0&0&0&0&1&1&1&0&0\\
        0&0&0&0&0&1&1&1&0\\
        0&0&0&0&0&0&1&1&1\\
    \end{array}\right].$$
\end{itemize}
\end{ejemplo}

Los códigos cíclicos se pueden caracterizar a partir de los ceros del polinomio $x^n - 1$, es decir, a partir de las raíces n-ésimas de la unidad. Esta caracterización nos será de utilidad cuando estudiemos los códigos BCH.

Recordemos que el Teorema \ref{th:fac} nos dice que si $t = ord_n(q)$, entonces $\mathbb{F}_{q^t}$ es un cuerpo de descomposición del polinomio $x^n - 1$. Así, $\mathbb{F}_{q^t}$ contiene una raíz n-ésima primitiva de la unidad $\alpha$ y $x^n - 1 = \prod_{i=0}^{n-1}(x-\alpha^i)$ es la factorización de $x^n - 1$ en $\mathbb{F}_{q^t}$ mediante polinomios de grado uno. Además, $x^n - 1 = \prod_{s}M_{\alpha^s}(x)$ es la factorización de $x^n - 1$ utilizando polinomios irreducibles en $\mathbb{F}_q$ , donde $s$ varía en un conjunto de representantes de las clases $q$-ciclotómicas módulo $n$.

Sea $\mathcal{C}$ un código cíclico en $\mathcal{R}_n$ generado por el polinomio $g(x)$. Por los Teoremas \ref{th:fac} y \ref{th:ci}, el polinomio $g(x)$ se puede factorizar de la siguiente manera: \begin{equation}\label{eq:fac} g(x) = \prod_{s}M_{\alpha^s}(x) = \prod_{s}\prod_{i \in C_s}(x-\alpha^i),\end{equation} donde $s$, de nuevo, varía en un conjunto de representantes de las clases $q$-ciclotómicas módulo $n$. Sea $T = \bigcup_{s}C_s$ la unión de estas clases $q$-ciclotómicas, las raíces de la unidad $\mathcal{Z} = \{\alpha^i \ | \ i \in T \}$ se llaman \emph{ceros} del código cíclico $\mathcal{C}$ . El conjunto $T$ se denomina \emph{conjunto característico} de $\mathcal{C}$.

El siguiente teorema nos proporciona propiedades básicas de los códigos cíclicos a partir de sus conjuntos característicos.

\begin{teorema}\label{th:cc}
  Sea $\alpha$ una raíz $n$-ésima primitiva de la unidad en algún cuerpo de descomposición de $\mathbb{F}_q$ con conjunto característico $T$ y polinomio generador $g(x)$. Se verifican las siguientes afirmaciones:
  \begin{itemize}
    \item[(i)] El polinomio $g(x)$ se factoriza como $g(x) = \prod_{i \in T}(x - \alpha^i)$.
    \item[(ii)] La palabra código $c(x) \in \mathcal{R}_n$ está en $\mathcal{C}$ si y solo si $c(\alpha^i) = 0$, $\forall i \in T$.
    \item[(iii)]  La dimensión de $\mathcal{C}$ es $n - |T|$.
    \end{itemize}
\end{teorema}

\begin{proof}
  \phantom{} \\
  \begin{itemize}
    \item La propiedad \textit{(i)} se deduce fácilmente de \eqref{eq:fac} teniendo en cuenta que $T = \bigcup_{s}C_s$.
    \item Recordemos que por el Teorema \ref{th:ci}, $c(x)$ es múltiplo de $g(x)$. Además, este mismo teorema nos asegura que $g(\alpha^i) = 0$, $\forall i \in T$, lo que prueba \textit{(ii)}.
    \item La prueba de \textit{(iii)} es directa utilizando, de nuevo, el Teorema \ref{th:ci}, ya que por \textit{(i)},  $|T|$ es igual al grado del polinomio $g(x)$.
  \end{itemize}
\end{proof}

\section{Códigos BCH}

En esta sección estudiaremos una de las familias más importantes de códigos cíclicos: los códigos BCH. También estudiaremos una subfamilia de estos códigos, los códigos Reed-Solomon. Los códigos BCH fueron diseñados para aprovechar la \emph{cota de Bose-Ray-Chaudhuri-Hocquenghem}, abreviada como \emph{cota BCH}. La cota BCH dependerá de los ceros del código y, en particular, de la posibilidad de encontrar cadenas de ceros “consecutivas”.

En lo que sigue, consideraremos que $\mathcal{C}$ es un código cíclico de longitud $n$ en $\mathbb{F}_q$ y que $\alpha$ es una raíz $n$-ésima primitiva de la unidad en $\mathbb{F}_{q^t}$, donde $t = ord_n(q)$. Recordemos que $T$ es un conjunto característico de $\mathcal{C}$ siempre y cuando los ceros de $\mathcal{C}$ sean $\{\alpha^i \ | \ i \in T\}$. Por tanto, $T$ debe ser una unión de clases $q$-ciclotómicas módulo $n$. Diremos que $T$ contiene un subconjunto consecutivo de $s$ elementos $\mathcal{S}$ si existe un conjunto $\{b,b+1,\dots,b + s + 1\}$ de $s$ elementos consecutivos tal que 
$$\{b,b+1,\dots,b + s + 1\} \ \ \text{mod  }n = \mathcal{S} \subseteq T.$$

Antes de proceder con la cota BCH, enunciaremos un lema conocido que usaremos en la demostración de la cota.

Sean $\alpha_1,\dots,\alpha_s$ elementos de un cuerpo $\mathbb{F}$. Una matriz de la forma
$$
  V =
  \begin{pmatrix}
    1 & 1 & \cdots & 1 \\
    \alpha_1 & \alpha_2 & \cdots & \alpha_s \\
    \alpha_1^2 & \alpha_2^2 & \cdots & \alpha_s^2 \\
    \vdots & \vdots & \ddots & \vdots \\
    \alpha_1^{s-1} & \alpha_2^{s-1} & \cdots & \alpha_s^{s-1}
  \end{pmatrix}
$$
se llama \emph{matriz de Vandermonde} \footnote{A la transpuesta de $V$ también se le conoce como matriz de Vandermonde.}.

\begin{lema}\label{lm:Vand}
El determinante de una matriz de Vandermonde viene dado por $$ \det (V) = \prod_{1\leq i < j \leq s}(\alpha_j - \alpha_i).$$
En particular, $V$ es regular si los elementos $\alpha_1,\dots,\alpha_s$ son distintos.
\end{lema}

Ya tenemos las herramientas necesarias para demostrar el teorema de la cota BCH.

\begin{teorema}[Cota BCH]\label{th:cota}
Sea $\mathcal{C}$ un código cíclico de longitud $n$ sobre $\mathbb{F}_q$ y sea $T$ su conjunto característico. Supongamos que $\mathcal{C}$ tiene peso mínimo $d$ y que $T$ contiene $\delta - 1$ elementos consecutivos para algún entero $\delta$. Entonces $d \geq \delta$.
\end{teorema}

\begin{proof}

Sean $\alpha^b,\alpha^{b+1},\dots,\alpha^{b+\delta-2}$ los $\delta - 1$ ceros consecutivos de $\mathcal{C}$. Sea $c(x)$ una palabra código no nula en $\mathcal{C}$ cuyo peso de Hamming es $w$, de la forma
$$c(x) = \sum_{j=1}^{w}c_{i_j}x^{i_j}.$$
Supongamos que $w < \delta$. Como $c(\alpha^i) = 0$ para $i \in \{b,b+1,\dots,b+\delta - 2\}$, se tiene que $M\mathbf{u}^T = \mathbf{0}$, con 

$$M = \left[
\begin{array}{cccc}
\alpha^{i_1 b} & \alpha^{i_2b} & \cdots & \alpha^{i_wb} \\
\alpha^{i_1 (b+1)} & \alpha^{i_2(b+1)} & \cdots & \alpha^{i_w(b+1)} \\
\vdots & \vdots & \ddots & \vdots \\
\alpha^{i_1(b+w-1)} & \alpha^{i_2(b+w-1)} & \cdots & \alpha^{i_w(b+w-1)} \\
\end{array}
\right]$$
y $\mathbf{u} = (c_{i_1},c_{i_2},\dots,c_{i_w})$. Puesto que $\mathbf{u} \neq \mathbf{0}$, $M$ es una matriz singular, y, por tanto, $\det(M)=0$. Sin embargo, $\det(M) = \alpha^{(i_1+i_2+\cdots i_w)b}\det(V)$, donde $V$ es la matriz de Vandermonde 

$$V = \left[
\begin{array}{cccc}
1 & 1 & \cdots & 1 \\
\alpha^{i_1} & \alpha^{i_2} & \cdots & \alpha^{i_w} \\
\vdots & \vdots & \ddots & \vdots \\
\alpha^{i_1(w-1)} & \alpha^{i_2(w-1)} & \cdots & \alpha^{i_w(w-1)} \\
\end{array}
\right].$$
Como los $\alpha^{i_j}$ son distintos, $\det(V) \neq 0$ por el Lema \ref{lm:Vand}, lo que contradice que $\det(M) = 0$.
\end{proof}

Recordemos que la efectividad de un código $\mathcal{C}$ a la hora de corregir errores depende de su dimensión y de su peso mínimo, los cuales nos gustaría maximizar. Tener un peso mínimo grande, basándonos en la cota BCH, puede conseguirse eligiendo un conjunto característico $T$ de $\mathcal{C}$ con un gran número de elementos consecutivos. Puesto que por el Teorema \ref{th:cc} la dimensión de $\mathcal{C}$ es $n - |T|$, lo ideal sería que $|T|$ sea lo más pequeño posible. Así, si queremos que $\mathcal{C}$ tenga distancia mínima de al menos $\delta$, podemos elegir un conjunto característico tan pequeño como sea posible que sea unión de clases $q$-ciclotómicas con $\delta - 1$ elementos consecutivos.

\begin{definicion}
Sea $\delta \in \{2,\dots,n\}$.  Un \emph{código BCH} $\mathcal{C}$ sobre $\mathbb{F}_q$ de longitud $n$ y distancia mínima designada $\delta$ es un código cíclico con conjunto característico 
\begin{equation}\label{eq:bch}T = C_b \cup C_{b+1} \cup \cdots \cup C_{b+\delta-2},\end{equation} donde $C_i$ es la clase $q$-ciclotómica módulo n que contiene a $i$.
\end{definicion}

\begin{teorema}\label{th:bch}
Un código BCH de distancia mínima designada $\delta$ tiene peso mínimo de al menos $\delta$.
\end{teorema}

\begin{proof}
El conjunto característico \eqref{eq:bch} contiene $\delta - 1$ elementos consecutivos. El resultado se sigue de la cota BCH \ref{th:cota}.
\end{proof}

\subsection{Códigos Reed-Solomon}\label{subsec:rs}

Una subfamilia importante de los códigos BCH son los códigos Reed-Solomon, que abreviaremos como códigos RS.

\begin{definicion}
\emph{Un código Reed-Solomon (RS)} sobre $\mathbb{F}_q$ es un código BCH de longitud $n = q-1$.
\end{definicion}

De este modo, $ord_n(q) = 1$ implica que todos los factores irreducibles de $x^n-1$ son de grado uno y todas las clases $q$-ciclotómicas módulo $n$ tienen tamaño $1$. El siguiente teorema nos da algunas propiedades de los códigos RS.

\begin{teorema}
Sea $\mathcal{C}$ un código RS sobre $\mathbb{F}_q$ de longitud $n = q-1$ y distancia mínima designada $\delta$. Entonces:
\begin{itemize}
  \item[(i)] El código $\mathcal{C}$ tiene un conjunto característico de la forma $T = \{b,b+1,\dots,b+\delta-2\}$.
  \item[(ii)] El código $\mathcal{C}$ tiene distancia mínima $d = \delta$ y dimensión $k = n-d+1$. 
\end{itemize}
\end{teorema}

\begin{proof}
Veamos la demostración por apartados.
\begin{itemize} 
  \item La propiedad \textit{(i)} se deduce teniendo en cuenta que al ser un código BCH de distancia mínima designada $\delta$, su conjunto característico $T$ tiene que tener tamaño $\delta - 1$ y en consecuencia $T = \{b,b+1,\dots,b+\delta-2\}$.
  \item El Teorema \ref{th:cc} nos dice que la dimensión de $\mathcal{C}$ es $k = n - |T| = n - \delta + 1$. Además, la cota de Singleton \ref{th:cotaS} y el Teorema \ref{th:bch} nos aseguran que $k = n - \delta + 1 \geq n - d + 1 \geq k$, y, por tanto, $k = n - d + 1$, lo que prueba \textit{(ii)}.
\end{itemize}
\end{proof}

\section{Decodificación de códigos BCH con el algoritmo de Sugiyama}\label{sec:sugiyama}

En esta sección vamos a ver un algoritmo de decodificación para códigos BCH, el conocido \emph{algoritmo de Sugiyama}. Este algoritmo fue creado por Sugiyama, Kasahara, Hirasawa y Namekawa en 1975 \cite{sugiyama1975method}. Se diseñó para una clase de códigos llamada la clase de los códigos de Goopa, los cuales incluyen a los códigos BCH como una subclase suya. Sin embargo, en esta sección solo lo aplicaremos a códigos BCH. Este algoritmo es una aplicación del algoritmo de Euclides para polinomios \ref{th:ae}.
 
Sea $\mathcal{C}$ un código BCH sobre $\mathbb{F}_q$ de longitud $n$, distancia designada $\delta$ y conjunto característico $T$, con $\{b,b+1,\dots,b + \delta - 2\} \subseteq T$. Puesto que la distancia mínima de $\mathcal{C}$ es al menos $\delta$, por el Teorema \ref{th:errores}, $\mathcal{C}$ puede corregir hasta $ t = \left\lfloor \frac{\delta-1}{2} \right\rfloor $ errores. El algoritmo de Sugiyama nos permitirá corregir estos $t$ errores.

Como en cualquier algoritmo de decodificación, si suponemos que recibimos un mensaje $y(x)$, nosotros queremos obtener la palabra código original $c(x)$. Supondremos que $y(x)$ difiere de $c(x)$ a lo sumo en $t$ coordenadas. Por tanto, $$y(x) = c(x) + e(x),$$ donde $e(x)$ es el \emph{vector de errores} cuyo peso de Hamming es $\nu \leq t$. Supongamos que los errores ocurren en unas coordenadas desconocidas $k_1,k_2,\dots,k_{\nu}$. Entonces: \begin{equation}\label{eq:error}e(x) = e_{k_1}x^{k_1} + e_{k_2}x^{k_2} + \cdots  e_{k_{\nu}}x^{k_{\nu}}\end{equation}
Una vez determinemos el vector de errores $e(x)$, lo que equivale a encontrar las coordenadas de error $k_j$ y las magnitudes del error $e_{k_j}$, \  $j \in \{1,\dots,\nu \}$, podremos decodificar el vector recibido como $c(x) = y(x) - e(x)$. Recordemos que por el Teorema \ref{th:cc}, $c(x) \in \mathcal{C}$ si y solo si $c(\alpha^i) = 0$ para todo $i \in T$. En particular, dado que $t = \left\lfloor \frac{\delta-1}{2} \right\rfloor$ y que $T$ contiene a $\{b,b+1,\dots,b + \delta - 2\}$, se tiene que $$y(\alpha^i) = c(\alpha^i) + e(\alpha^i) = e(\alpha^i), \ \ \forall i \in \{b,b+1,\dots,b + 2t - 1\}.$$
Para $i \in \{b,b+1,\dots,b + 2t - 1\}$ definimos \emph{el síndrome} $S_i$ de $y(x)$ como el elemento  $S_i = y(\alpha^i)$ en $\mathbb{F}_{q^m}$.

El primer paso del algoritmo de Sugiyama será calcular los síndromes para un vector $y(x)$ que se ha recibido. Estos síndromes nos conducen a un sistema de ecuaciones que involucran tanto a las coordenadas de error desconocidas como a las magnitudes de error. Nótese que de \eqref{eq:error} los síndromes satisfacen \begin{equation}\label{eq:sin}
  S_i = y(\alpha^i) = e(\alpha^i) = \sum_{j=1}^{\nu}e_{k_j}(\alpha^i)^{k_j} = \sum_{j=1}^{\nu}e_{k_j}(\alpha^{k_j})^{i}, \ \ i \in \{b,b+1,\dots,b + 2t - 1\}.
\end{equation}

Con el objetivo de simplificar la notación, para $j \in \{1,\dots,\nu\}$ definimos:
\begin{itemize}
  \item $E_j = e_{k_j}$, que será la magnitud del error en la coordenada $k_j$.
  \item $X_j = \alpha^{k_j}$, que llamaremos número de coordenadas de error correspondiente a la coordenada de error $k_j$.
\end{itemize}

Por el Teorema \ref{th:ep}, si $\alpha^i = \alpha^k$ con $i \in \{0,\dots,n-1\}$, entonces $i = k$. Por tanto, conociendo $X_j$ conoceremos también la coordenada de error $k_j$. Con la notación anterior, \eqref{eq:sin} se puede expresar como:

\begin{equation}\label{eq:sin2}
  S_i = \sum_{j=1}^{\nu}E_jX_j^i, \ \ i \in \{b,b+1.\dots,b + 2t - 1\}.
\end{equation}

La expresión anterior nos conduce al sistema de ecuaciones

\begin{equation}
  \label{eq:sistema}
  \begin{cases}
    S_b = E_1X_1^b + E_2X_2^b + \cdots + E_{\nu}X_{\nu}^b ,\\
    S_{b+1} = E_1X_1^{b+1} + E_2X_2^{b+1} + \cdots + E_{\nu}X_{\nu}^{b+1},\\
    S_{b+2} = E_1X_1^{b+2} + E_2X_2^{b+2} + \cdots + E_{\nu}X_{\nu}^{b+2},\\
    \ \ \ \ \ \  \ \ \  \ \ \  \ \ \  \ \ \  \ \ \  \ \ \ \vdots \\
    S_{b + 2t - 1} = E_1X_1^{b + 2t - 1} + E_2X_2^{b + 2t - 1} + \cdots + E_{\nu}X_{\nu}^{b + 2t - 1}.\\
  \end{cases}
\end{equation}

Este sistema es no lineal para los $X_j$, y además, desconocemos tanto los valores de los $E_j$ como de los $X_j$. La estrategia será calcular directamente los números de coordenadas de error. Una vez conozcamos los $X_j$, volveremos al sistema \eqref{eq:sistema}, que será un sistema lineal formado únicamente por los $E_j$. Para este fin, definimos el \emph{polinomio localizador de errores} como $$\sigma(x) = \prod_{j=1}^{\nu}(1 - xX_j) =  (1- xX_1)(1 - xX_2)\cdots(1- xX_{\nu}) = 1 + \sum_{i=1}^{\nu}\sigma_ix^i.$$

Nótese que $\sigma(x) = 0$ si y solo si $x = X_j^{-1}$, $j \in \{1,\dots,\nu\}$. Por tanto, calculando las raíces del polinomio localizador de errores, calcularemos los inversos de los números de coordenadas de error, y podremos obtener los $X_j$ fácilmente.

\begin{definicion}
El \emph{polinomio evaluador de errores} se define como \begin{equation}\label{eq:sc}\omega(x) = \sum_{j=1}^{\nu}E_jX_j^b\prod_{\substack{i=1 \\ i \neq j}}^{\nu} (1 - x X_i) = \sum_{j=1}^{\nu}E_jX_j^b\frac{\sigma(x)}{1 - xX_j}.
\end{equation}
\end{definicion}

Observamos que $\gr(\sigma(x)) = \nu$ y $\gr(\omega(x)) \leq \nu - 1$. Ahora definimos el polinomio $S(x)$ de grado máximo $2t - 1$ como $$S(x) = \sum_{i=0}^{2t-1}S_{i+b}x^i,$$ donde los $S_i$ son los síndromes del vector recibido, $i \in \{b,b+1,\dots,b + 2t - 1\}$. 

\begin{teorema} Se cumple la siguiente relación
  $$\omega(x) \equiv \sigma(x)S(x) \mod x^{2t}.$$
\end{teorema}

\begin{proof}
Obsérvese que $$(1 - ax)\left(\sum_{i=0}^{m-1}(ax)^i\right) \equiv 1 \mod x^m.$$

Por tanto, operando módulo $x^{2t}$,

\begin{align*}
  \omega(x) &= \sigma(x) \sum_{j=1}^{\nu}E_j X_j^b \frac{1}{1 - x X_j} = \sigma(x)\sum_{j=1}^{\nu} E_j X_j^b\sum_{i=0}^{2t - 1}(xX_j)^i \\
  &= \sigma(x)\sum_{i=0}^{2t - 1}\sum_{j=1}^{\nu} E_j X_j^{i+b}x^i = \sigma(x) \sum_{i=0}^{2t-1}S_{i+b}x^i = \sigma(x)S(x).
\end{align*}


\end{proof}


Llegamos a esta ecuación, llamada \emph{ecuación clave}.
\begin{equation}\label{eq:ke}
  \omega(x) \equiv \sigma(x)S(x) \mod x^{2t}.
\end{equation}

El algoritmo de Sugiyama consistirá en resolver la ecuación \eqref{eq:ke}.

La siguiente observación nos será útil después.
\begin{lema}\label{lema:co}
Los polinomios $\omega(x)$ y $\sigma(x)$ son coprimos.
\end{lema}

\begin{proof} Las raíces de $\sigma(x)$ son precisamente $X_j^{-1}$, para $j \in \{1,\dots,\nu\}$. Pero
  $$\omega(X_j^{-1}) = E_jX_j\prod_{\substack{i=1 \\ i \neq j}}^{\nu} (1 - X_j^{-1} X_i) \neq 0,$$
  lo que concluye la demostración del lema.
\end{proof}

Una vez tengamos las raíces de $\sigma(x)$, tendremos que invertirlas para determinar los números de coordenadas de error. Cuando tengamos los $X_j$, podremos resolver el sistema \eqref{eq:sistema}, obteniendo así los valores de $E_j$. Teniendo los valores de $X_j$ y $E_j$, es fácil obtener los valores de $k_j$ y $e_{k_j}$,  los que nos proporciona directamente el vector de error $e(x)$. Por último, recordemos que el mensaje original $c(x)$, se obtiene como $c(x) = y(x) - e(x)$, lo que concluye la decodificación del mensaje.

En resumen, el algoritmo de Sugiyama consiste en:

\begin{algoritmo}[Algoritmo de Sugiyama]\label{alg:bchsugiyama}
  \phantom{\\}
  \begin{enumerate}
    \item[(i)] Calculamos el síndrome $S(x)$.
    \item[(ii)] Sean $f(x) = x^{2t}$ y $s(x) = S(x)$. Fijamos $r_{-1}(x) = f(x), r_0(x) = s(x), b_{-1}(x) = 0,$ y $b_0(x) = 1$.
    \item[(iii)] Encontrar $h_i(x),r_i(x)$ y $b_i(x)$ de manera inductiva para $i = 1,2,\dots,I$, hasta que $I$ cumpla que $\gr(r_{I-1}(x)) \geq t$ y $\gr(r_{I}(x)) < t$ mediante las dos siguientes fórmulas: \begin{align*}
      r_{i-2}(x) &= r_{i-1}(x)h_i(x) + r_i(x), \text{       donde } \gr(r_i(x)) < \gr(r_{i-1}(x)), \\
      b_i(x) &= b_{i-2}(x) - h_i(x)b_{i-1}(x).
    \end{align*}
    $\sigma(x)$ es un múltiplo escalar no nulo de $b_I(x)$, es decir, $\sigma(x) = \lambda b_I(x)$ para alguna constante $\lambda$ no nula. Así, las raíces de $\sigma(x)$ son las mismas que las de $b_I(x)$.
    \item[(iv)] Calculamos las raíces de $b_I(x)$ y las invertimos para obtener los números de coordenadas de error $X_j$.
    \item[(v)] Utilizamos los $X_j$ para resolver el sistema \ref{eq:sistema} y así obtener las magnitudes de error $E_j$.
    \item[(vi)] Calculamos el vector de errores $e(x)$ y se lo restamos al mensaje $y(x)$. 
  \end{enumerate}
\end{algoritmo}

Observemos que $I$ está bien definido, ya que el grado de $r_i(x)$ decrece estrictamente. El siguiente lema nos será útil para demostrar posteriormente la eficacia del algoritmo de Sugiyama. La demostración puede consultarse en \cite[p.~191]{Huffman_Pless_2010}.

\begin{lema}\label{lema:as}
Usando la notación del algoritmo de Sugiyama \ref{alg:bchsugiyama}, sea $a_{-1}(x) = 1$, $a_0(x) = 0$, y $a_i(x) = a_{i-2}(x) - h_i(x)a_{i-1}(x)$ para $i \geq 1$. Se verifican:
\begin{itemize}
  \item[(i)] $a_i(x)f(x) + b_i(x)s(x) = r_i(x)  \text{   para } i \geq -1.$
  \item[(ii)] $b_i(x)r_{i-1}(x) - b_{i-1}(x)r_i(x) = (-1)^i f(x) \text{   para } i \geq 0.$
  \item[(iii)] $a_i(x)b_{i-1}(x) - a_{i-1}(x)b_i(x) = (-1)^{i+1}  \text{   para } i \geq 0.$
  \item[(iv)]  $\gr(b_i(x)) +  \gr(r_{i-1}(x)) =  \gr(f(x)) \text{   para } i \geq 0.$
\end{itemize}
\end{lema}

Ahora debemos verificar que el paso (ii) del algoritmo de Sugiyama funciona, es decir, debemos probar que  $\sigma(x) = \lambda b_I(x), \lambda \neq 0$. 

\begin{teorema} 
En las condiciones del algoritmo de Sugiyama \ref{alg:bchsugiyama} se cumple que existe un escalar no nulo $\lambda$ tal que
$$\sigma(x) = \lambda b_I(x).$$
  
\end{teorema}
\begin{proof}
Utilizando el Lema \ref{lema:as} (i), tenemos que
\begin{equation}\label{eq:d1}
a_I(x)x^{2t} + b_I(x)S(x) = r_I(x).
\end{equation}

De la ecuación clave \eqref{eq:ke}, también sabemos que para algún polinomio $a(x)$ se cumple
\begin{equation}\label{eq:d2}
a(x)x^{2t} + \sigma(x)S(x) = \omega(x).
\end{equation}

Multiplicamos \eqref{eq:d1} por $\sigma(x)$ y \eqref{eq:d2} por $b_I(x)$ para obtener

\begin{align}
    a_I(x)\sigma(x)x^{2t} + b_I(x)\sigma(x)S(x) &= r_I(x)\sigma(x), \label{eq:d3}\\
    a_I(x)b_I(x)x^{2t} + \sigma(x)b_I(x)S(x) &= \omega(x)b_I(x) \label{eq:d4}.
\end{align}

Operando módulo $x^{2t}$, esto implica que 

\begin{equation}\label{eq:d5}
r_I(x)\sigma(x) \equiv \omega(x)b_I(x) \mod x^{2t}.
\end{equation}

Puesto que $\gr(\sigma(x)) \leq t$, por la elección de $I$, $$\gr(r_I(x)\sigma(x)) = \gr(r_I(x)) + \gr(\sigma(x)) < t + t = 2t.$$

Por el Lema \ref{lema:as} (iv), la elección de $I$ y el hecho de que $\gr(\omega(x)) < t$ se tiene que
  $$\gr(\omega(x)b_I(x)) = \gr(\omega(x)) + \gr(b_I(x))  \\
  < t + \gr(b_I(x)) = t + (\gr(x^{2t}) - \gr(r_{I-1}(x))) \leq 3t - t = 2t.$$

Por tanto, \eqref{eq:d5} implica que $r_I(x)\sigma(x) = \omega(x)b_I(x)$. Esto, junto a \eqref{eq:d3} y \eqref{eq:d4}, prueba que
\begin{equation}\label{eq:d6}
  a_I(x)\sigma(x) = a(x)b_I(x).
\end{equation}

Sin embargo, el Lema \ref{lema:as} (iii) nos dice que $a_I(x)$ y $b_I(x)$ son coprimos y, por tanto, $a(x) = \lambda(x)a_I(x)$ por \eqref{eq:d6}. Sustituyendo esto en \eqref{eq:d6} se tiene que 
\begin{equation}\label{eq:d7}
  \sigma(x) = \lambda(x)b_I(x).
\end{equation}

Sustituyendo de nuevo en \eqref{eq:d2} $$\lambda(x)a_I(x)x^{2t} + \lambda(x)b_I(x)S(x) = \omega(x).$$

Así, \eqref{eq:d1} implica que 
\begin{equation}\label{eq:d8}
  \omega(x) = \lambda(x)r_I(x)
\end{equation}

Por el Lema \ref{lema:co}, \eqref{eq:d7} y \eqref{eq:d8}, $\lambda(x)$ debe ser una constante no nula, verificando el paso (ii) del algoritmo de Sugiyama.
\end{proof}

\begin{algorithm}[H]
  \caption{Algoritmo de Sugiyama para códigos BCH}\label{SugiyamaBCH}
  \begin{algorithmic}[1]
  \REQUIRE Un polinomio recibido $y=\sum_{i=0}^{n-1}y_ix^i$ obtenido tras la transmisión de una palabra código $c \in \C$, donde $\C$ es un código BCH con capacidad de corrección de $t$ errores.
  \ENSURE Una palabra código $c'$.
  
  \FOR{\(b \leq i \leq b + 2t-1\)}
      \STATE $S_i \gets y(\alpha^i)$
  \ENDFOR
  \STATE $S(x) \gets \sum_{i=0}^{2t-1} S_{i+b} x^i$
  
  \STATE $f(x) \gets x^{2t}$
  \STATE $s(x) \gets S(x)$
  \STATE $r_{-1}(x) \gets f(x)$, $r_0(x) \gets s(x)$
  \STATE $b_{-1}(x) \gets 0$, $b_0(x) \gets 1$
  \STATE $i \gets 1$

  \WHILE{$\gr(r_{i-1}(x)) \geq t$ \OR $\gr(r_i(x)) < t$}
    \STATE $(\text{q}, \text{rem}) \gets \text{quo-rem}(r_{i-2},r_{i-1})$
    \STATE $r_{i-2}(x) \gets r_{i-1}(x)$
    \STATE $r_{i-1}(x) \gets \text{rem}$
    \STATE  $b_i(x) \gets b_{i-2}(x) - \text{q} \cdot b_{i-1}(x)$
    \STATE $b_{i-2}(x) \gets b_{i-1}(x)$
    \STATE $b_{i-1}(x) \gets b_i(x)$
    \STATE $i \gets i + 1$
  \ENDWHILE

  \STATE $I \gets i$

  \STATE Calcular las raíces de $b_I(x)$ e invertirlas para obtener las posiciones de error $X_j$
  
  \STATE $k_j \gets [\log_a(x_j) \text{ para cada } x_j \text{ en } X_j]$

  \STATE Utilizar los $X_j$ para resolver el sistema de ecuaciones y obtener las magnitudes de error $E_j$
  
  \STATE $e(x) \gets \sum_{j} E_j x^{k_j}$
  \RETURN $y(x) - e(x)$
  
  \end{algorithmic}
\end{algorithm}


A partir de este algoritmo, se ha realizado una implementación en SageMath \cite{SageMath2022} que puede consultarse en el enlace del apéndice \ref{ap:codigo}. Veamos un ejemplo donde se usa esta implementación.

\begin{ejemplo}
Sea $\C$ un $[15,7]$-código BCH binario con distancia designada $\delta = 5$ y con conjunto característico $T = \{1, 2, 3, 4, 6, 8, 9, 12\}$.

Vamos a suponer que queremos enviar el mensaje $\mathbf{m} = 1001010$.

En primer lugar, lo codificamos mediante la matriz generadora.
\begin{lstlisting}[gobble=1]
  sage: F = GF(2)
  sage: C = BCHCode(F,15,5,offset = 1)
  sage: C
  > [15, 7] BCH Code over GF(2) with designed distance 5
  sage: message = vector([1,0,0,1,0,1,0])
  sage: G = C.generator_matrix()
  sage: G
  > [1 0 0 0 1 0 1 1 1 0 0 0 0 0 0]
    [0 1 0 0 0 1 0 1 1 1 0 0 0 0 0]
    [0 0 1 0 0 0 1 0 1 1 1 0 0 0 0]
    [0 0 0 1 0 0 0 1 0 1 1 1 0 0 0]
    [0 0 0 0 1 0 0 0 1 0 1 1 1 0 0]
    [0 0 0 0 0 1 0 0 0 1 0 1 1 1 0]
    [0 0 0 0 0 0 1 0 0 0 1 0 1 1 1]
  sage: codeword = message * G
  sage: codeword
  > (1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0)
\end{lstlisting}

De esta forma, hemos obtenido la palabra código es $\mathbf c = 100111101010110$.

Una vez se ha codificado el mensaje original, vamos a suponer que se ha producido un error durante la transmisión de la palabra código, dicho error será $\mathbf e = 010000000000001$. Por tanto, la palabra que se ha recibido ha sido
$$\mathbf y = \mathbf c + \mathbf e = 100111101010110 + 010000000000001 = 110111101010111.$$


Vamos a utilizar el algoritmo de Sugiyama para decodificar la palabra que se ha recibido, y así obtener la palabra código original.

\begin{lstlisting}[gobble=1]
  sage: error_vector = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
  sage: received_message = coded_message + error_vector
  sage: D = BCHSugiyamaDecoder(C)
  sage: R = PolynomialRing(GF(2),'x')
  sage: y = R(list(received_message))
  sage: DEBUG = True
  sage: D.decode_to_code(y)
  > The code has a correction capability of 2  errors.
  > List of syndromes:  [z4^3 + z4^2 + z4 + 1, z4^3 + z4, z4, z4^3]
  > Xj : [z4^3 + z4^2 + 1, z4]
  > The number of errors are : 2
  > Position of the errors: [13, 1]
  > Error magnitudes: (1, 1)
  > Error vector: (1, 1)
  > Codeword in polynomial form:  x^13 + x^12 + x^10 + x^8 + x^6 + x^5 + x^4 + x^3 + 1
\end{lstlisting}

Observamos que el algoritmo de Sugiyama ha detectado dos errores, en las posiciones 1 y 13, ambas de magnitud 1. Por tanto, la palabra código corregida es $\mathbf c = 100111101010110$, tal y como buscábamos.


\end{ejemplo}


  

\endinput